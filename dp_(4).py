# -*- coding: utf-8 -*-
"""Dp (4).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-_xCf2klDCBlmRwU89bbV6jqbzI9RAH7
"""

!pip install gradio

import numpy as np
import gradio as gr
import torch
import matplotlib.pyplot as plt
from transformers import AutoModelForSequenceClassification, AutoTokenizer, pipeline

"""#Loading the Model"""

model = None  # Initialize model variable
try:
    # Load the model from the specified path
    model = AutoModelForSequenceClassification.from_pretrained("/content/contentsaved_model_bert_sentiment")
    model_weights = torch.load("//content/contentsaved_model_bert_sentiment/model.safetensors")
    model.load_state_dict(model_weights)
except Exception as e:
    print(f"Error loading model: {str(e)}")  # Print error message if loading fails

"""# Load the tokenizer"""

tokenizer = AutoTokenizer.from_pretrained("/content/contentsaved_model_bert_sentiment")

"""# Set up the sentiment analysis pipeline"""

if model is not None:
    sentiment_pipeline = pipeline("sentiment-analysis", model=model, tokenizer=tokenizer)
else:
    sentiment_pipeline = None  # Set pipeline to None if model is not loaded

"""#Review Classification Function with Plot"""

def classify_review_with_plot(review):
    if sentiment_pipeline is None:
        return "Error: Sentiment analysis model is not loaded.", None  # Error message if model is not loaded

    try:
        result = sentiment_pipeline(review)  # Analyze sentiment for the review
        label = result[0]['label']  # Get the label from the model
        score = result[0]['score']  # Confidence score

        # Create a mapping for labels
        label_mapping = {
            "LABEL_0": "NEGATIVE",  # Assuming LABEL_0 corresponds to negative sentiment
            "LABEL_1": "NEUTRAL",   # Assuming LABEL_1 corresponds to neutral sentiment
            "LABEL_2": "POSITIVE"    # Assuming LABEL_2 corresponds to positive sentiment
        }

        # Map the label to a human-readable format
        human_readable_label = label_mapping.get(label, "UNKNOWN")  # Default to "UNKNOWN" if label is not found

        # Prepare values for the bar chart
        labels = ["Positive", "Negative", "Neutral"]
        values = [0, 0, 0]  # Initialize values for each category

        # Set values based on the mapped label
        if human_readable_label == "POSITIVE":
            values[0] = score
        elif human_readable_label == "NEGATIVE":
            values[1] = score
        elif human_readable_label == "NEUTRAL":
            values[2] = score

        # Create a bar chart
        fig, ax = plt.subplots()
        ax.bar(labels, values, color=["green", "red", "blue"])
        ax.set_ylabel("Confidence Score")
        ax.set_title("Review Classification")

        # Return the sentiment label and score
        sentiment_result = f"Sentiment: {human_readable_label}, Score: {score:.2f}"
        return sentiment_result, fig
    except Exception as e:
        return f"Error: {str(e)}", None  # Error message if an exception occurs

"""# Set up Gradio interface"""

with gr.Blocks() as app:
    gr.Markdown("## Review Analysis Application")  # Application title

    with gr.Tab("Review Classification"):  # Review classification tab
        review_input = gr.Textbox(label="Enter your review here", placeholder="Type your review here...")  # Review input field
        classify_button = gr.Button("Classify")  # Classification button
        classification_output = gr.Textbox(label="Classification Result")  # Classification result output field
        chart_output = gr.Plot(label="Graphical Results")  # Graphical results output field

        # Link the button to the function
        classify_button.click(classify_review_with_plot, inputs=review_input, outputs=[classification_output, chart_output])

"""# Launch the application"""

app.launch(share=True)